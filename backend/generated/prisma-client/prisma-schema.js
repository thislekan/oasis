module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.8). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateCourse {
  count: Int!
}

type AggregateDepartment {
  count: Int!
}

type AggregateFaculty {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Course {
  id: ID!
  name: String!
  department: Department!
  creditUnit: Int!
  students(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  description: String!
  level: String!
}

type CourseConnection {
  pageInfo: PageInfo!
  edges: [CourseEdge]!
  aggregate: AggregateCourse!
}

input CourseCreateInput {
  id: ID
  name: String!
  department: DepartmentCreateOneWithoutCoursesInput!
  creditUnit: Int!
  students: UserCreateManyWithoutCoursesInput
  description: String!
  level: String!
}

input CourseCreateManyWithoutDepartmentInput {
  create: [CourseCreateWithoutDepartmentInput!]
  connect: [CourseWhereUniqueInput!]
}

input CourseCreateManyWithoutStudentsInput {
  create: [CourseCreateWithoutStudentsInput!]
  connect: [CourseWhereUniqueInput!]
}

input CourseCreateWithoutDepartmentInput {
  id: ID
  name: String!
  creditUnit: Int!
  students: UserCreateManyWithoutCoursesInput
  description: String!
  level: String!
}

input CourseCreateWithoutStudentsInput {
  id: ID
  name: String!
  department: DepartmentCreateOneWithoutCoursesInput!
  creditUnit: Int!
  description: String!
  level: String!
}

type CourseEdge {
  node: Course!
  cursor: String!
}

enum CourseOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  creditUnit_ASC
  creditUnit_DESC
  description_ASC
  description_DESC
  level_ASC
  level_DESC
}

type CoursePreviousValues {
  id: ID!
  name: String!
  creditUnit: Int!
  description: String!
  level: String!
}

input CourseScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  creditUnit: Int
  creditUnit_not: Int
  creditUnit_in: [Int!]
  creditUnit_not_in: [Int!]
  creditUnit_lt: Int
  creditUnit_lte: Int
  creditUnit_gt: Int
  creditUnit_gte: Int
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  level: String
  level_not: String
  level_in: [String!]
  level_not_in: [String!]
  level_lt: String
  level_lte: String
  level_gt: String
  level_gte: String
  level_contains: String
  level_not_contains: String
  level_starts_with: String
  level_not_starts_with: String
  level_ends_with: String
  level_not_ends_with: String
  AND: [CourseScalarWhereInput!]
  OR: [CourseScalarWhereInput!]
  NOT: [CourseScalarWhereInput!]
}

type CourseSubscriptionPayload {
  mutation: MutationType!
  node: Course
  updatedFields: [String!]
  previousValues: CoursePreviousValues
}

input CourseSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CourseWhereInput
  AND: [CourseSubscriptionWhereInput!]
  OR: [CourseSubscriptionWhereInput!]
  NOT: [CourseSubscriptionWhereInput!]
}

input CourseUpdateInput {
  name: String
  department: DepartmentUpdateOneRequiredWithoutCoursesInput
  creditUnit: Int
  students: UserUpdateManyWithoutCoursesInput
  description: String
  level: String
}

input CourseUpdateManyDataInput {
  name: String
  creditUnit: Int
  description: String
  level: String
}

input CourseUpdateManyMutationInput {
  name: String
  creditUnit: Int
  description: String
  level: String
}

input CourseUpdateManyWithoutDepartmentInput {
  create: [CourseCreateWithoutDepartmentInput!]
  delete: [CourseWhereUniqueInput!]
  connect: [CourseWhereUniqueInput!]
  set: [CourseWhereUniqueInput!]
  disconnect: [CourseWhereUniqueInput!]
  update: [CourseUpdateWithWhereUniqueWithoutDepartmentInput!]
  upsert: [CourseUpsertWithWhereUniqueWithoutDepartmentInput!]
  deleteMany: [CourseScalarWhereInput!]
  updateMany: [CourseUpdateManyWithWhereNestedInput!]
}

input CourseUpdateManyWithoutStudentsInput {
  create: [CourseCreateWithoutStudentsInput!]
  delete: [CourseWhereUniqueInput!]
  connect: [CourseWhereUniqueInput!]
  set: [CourseWhereUniqueInput!]
  disconnect: [CourseWhereUniqueInput!]
  update: [CourseUpdateWithWhereUniqueWithoutStudentsInput!]
  upsert: [CourseUpsertWithWhereUniqueWithoutStudentsInput!]
  deleteMany: [CourseScalarWhereInput!]
  updateMany: [CourseUpdateManyWithWhereNestedInput!]
}

input CourseUpdateManyWithWhereNestedInput {
  where: CourseScalarWhereInput!
  data: CourseUpdateManyDataInput!
}

input CourseUpdateWithoutDepartmentDataInput {
  name: String
  creditUnit: Int
  students: UserUpdateManyWithoutCoursesInput
  description: String
  level: String
}

input CourseUpdateWithoutStudentsDataInput {
  name: String
  department: DepartmentUpdateOneRequiredWithoutCoursesInput
  creditUnit: Int
  description: String
  level: String
}

input CourseUpdateWithWhereUniqueWithoutDepartmentInput {
  where: CourseWhereUniqueInput!
  data: CourseUpdateWithoutDepartmentDataInput!
}

input CourseUpdateWithWhereUniqueWithoutStudentsInput {
  where: CourseWhereUniqueInput!
  data: CourseUpdateWithoutStudentsDataInput!
}

input CourseUpsertWithWhereUniqueWithoutDepartmentInput {
  where: CourseWhereUniqueInput!
  update: CourseUpdateWithoutDepartmentDataInput!
  create: CourseCreateWithoutDepartmentInput!
}

input CourseUpsertWithWhereUniqueWithoutStudentsInput {
  where: CourseWhereUniqueInput!
  update: CourseUpdateWithoutStudentsDataInput!
  create: CourseCreateWithoutStudentsInput!
}

input CourseWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  department: DepartmentWhereInput
  creditUnit: Int
  creditUnit_not: Int
  creditUnit_in: [Int!]
  creditUnit_not_in: [Int!]
  creditUnit_lt: Int
  creditUnit_lte: Int
  creditUnit_gt: Int
  creditUnit_gte: Int
  students_every: UserWhereInput
  students_some: UserWhereInput
  students_none: UserWhereInput
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  level: String
  level_not: String
  level_in: [String!]
  level_not_in: [String!]
  level_lt: String
  level_lte: String
  level_gt: String
  level_gte: String
  level_contains: String
  level_not_contains: String
  level_starts_with: String
  level_not_starts_with: String
  level_ends_with: String
  level_not_ends_with: String
  AND: [CourseWhereInput!]
  OR: [CourseWhereInput!]
  NOT: [CourseWhereInput!]
}

input CourseWhereUniqueInput {
  id: ID
  name: String
}

type Department {
  id: ID!
  name: String!
  faculty: Faculty!
  courses(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Course!]
}

type DepartmentConnection {
  pageInfo: PageInfo!
  edges: [DepartmentEdge]!
  aggregate: AggregateDepartment!
}

input DepartmentCreateInput {
  id: ID
  name: String!
  faculty: FacultyCreateOneWithoutDepartmentsInput!
  courses: CourseCreateManyWithoutDepartmentInput
}

input DepartmentCreateManyWithoutFacultyInput {
  create: [DepartmentCreateWithoutFacultyInput!]
  connect: [DepartmentWhereUniqueInput!]
}

input DepartmentCreateOneInput {
  create: DepartmentCreateInput
  connect: DepartmentWhereUniqueInput
}

input DepartmentCreateOneWithoutCoursesInput {
  create: DepartmentCreateWithoutCoursesInput
  connect: DepartmentWhereUniqueInput
}

input DepartmentCreateWithoutCoursesInput {
  id: ID
  name: String!
  faculty: FacultyCreateOneWithoutDepartmentsInput!
}

input DepartmentCreateWithoutFacultyInput {
  id: ID
  name: String!
  courses: CourseCreateManyWithoutDepartmentInput
}

type DepartmentEdge {
  node: Department!
  cursor: String!
}

enum DepartmentOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type DepartmentPreviousValues {
  id: ID!
  name: String!
}

input DepartmentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [DepartmentScalarWhereInput!]
  OR: [DepartmentScalarWhereInput!]
  NOT: [DepartmentScalarWhereInput!]
}

type DepartmentSubscriptionPayload {
  mutation: MutationType!
  node: Department
  updatedFields: [String!]
  previousValues: DepartmentPreviousValues
}

input DepartmentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DepartmentWhereInput
  AND: [DepartmentSubscriptionWhereInput!]
  OR: [DepartmentSubscriptionWhereInput!]
  NOT: [DepartmentSubscriptionWhereInput!]
}

input DepartmentUpdateDataInput {
  name: String
  faculty: FacultyUpdateOneRequiredWithoutDepartmentsInput
  courses: CourseUpdateManyWithoutDepartmentInput
}

input DepartmentUpdateInput {
  name: String
  faculty: FacultyUpdateOneRequiredWithoutDepartmentsInput
  courses: CourseUpdateManyWithoutDepartmentInput
}

input DepartmentUpdateManyDataInput {
  name: String
}

input DepartmentUpdateManyMutationInput {
  name: String
}

input DepartmentUpdateManyWithoutFacultyInput {
  create: [DepartmentCreateWithoutFacultyInput!]
  delete: [DepartmentWhereUniqueInput!]
  connect: [DepartmentWhereUniqueInput!]
  set: [DepartmentWhereUniqueInput!]
  disconnect: [DepartmentWhereUniqueInput!]
  update: [DepartmentUpdateWithWhereUniqueWithoutFacultyInput!]
  upsert: [DepartmentUpsertWithWhereUniqueWithoutFacultyInput!]
  deleteMany: [DepartmentScalarWhereInput!]
  updateMany: [DepartmentUpdateManyWithWhereNestedInput!]
}

input DepartmentUpdateManyWithWhereNestedInput {
  where: DepartmentScalarWhereInput!
  data: DepartmentUpdateManyDataInput!
}

input DepartmentUpdateOneInput {
  create: DepartmentCreateInput
  update: DepartmentUpdateDataInput
  upsert: DepartmentUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: DepartmentWhereUniqueInput
}

input DepartmentUpdateOneRequiredWithoutCoursesInput {
  create: DepartmentCreateWithoutCoursesInput
  update: DepartmentUpdateWithoutCoursesDataInput
  upsert: DepartmentUpsertWithoutCoursesInput
  connect: DepartmentWhereUniqueInput
}

input DepartmentUpdateWithoutCoursesDataInput {
  name: String
  faculty: FacultyUpdateOneRequiredWithoutDepartmentsInput
}

input DepartmentUpdateWithoutFacultyDataInput {
  name: String
  courses: CourseUpdateManyWithoutDepartmentInput
}

input DepartmentUpdateWithWhereUniqueWithoutFacultyInput {
  where: DepartmentWhereUniqueInput!
  data: DepartmentUpdateWithoutFacultyDataInput!
}

input DepartmentUpsertNestedInput {
  update: DepartmentUpdateDataInput!
  create: DepartmentCreateInput!
}

input DepartmentUpsertWithoutCoursesInput {
  update: DepartmentUpdateWithoutCoursesDataInput!
  create: DepartmentCreateWithoutCoursesInput!
}

input DepartmentUpsertWithWhereUniqueWithoutFacultyInput {
  where: DepartmentWhereUniqueInput!
  update: DepartmentUpdateWithoutFacultyDataInput!
  create: DepartmentCreateWithoutFacultyInput!
}

input DepartmentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  faculty: FacultyWhereInput
  courses_every: CourseWhereInput
  courses_some: CourseWhereInput
  courses_none: CourseWhereInput
  AND: [DepartmentWhereInput!]
  OR: [DepartmentWhereInput!]
  NOT: [DepartmentWhereInput!]
}

input DepartmentWhereUniqueInput {
  id: ID
  name: String
}

type Faculty {
  id: ID!
  name: String!
  departments(where: DepartmentWhereInput, orderBy: DepartmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Department!]
}

type FacultyConnection {
  pageInfo: PageInfo!
  edges: [FacultyEdge]!
  aggregate: AggregateFaculty!
}

input FacultyCreateInput {
  id: ID
  name: String!
  departments: DepartmentCreateManyWithoutFacultyInput
}

input FacultyCreateOneInput {
  create: FacultyCreateInput
  connect: FacultyWhereUniqueInput
}

input FacultyCreateOneWithoutDepartmentsInput {
  create: FacultyCreateWithoutDepartmentsInput
  connect: FacultyWhereUniqueInput
}

input FacultyCreateWithoutDepartmentsInput {
  id: ID
  name: String!
}

type FacultyEdge {
  node: Faculty!
  cursor: String!
}

enum FacultyOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type FacultyPreviousValues {
  id: ID!
  name: String!
}

type FacultySubscriptionPayload {
  mutation: MutationType!
  node: Faculty
  updatedFields: [String!]
  previousValues: FacultyPreviousValues
}

input FacultySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FacultyWhereInput
  AND: [FacultySubscriptionWhereInput!]
  OR: [FacultySubscriptionWhereInput!]
  NOT: [FacultySubscriptionWhereInput!]
}

input FacultyUpdateDataInput {
  name: String
  departments: DepartmentUpdateManyWithoutFacultyInput
}

input FacultyUpdateInput {
  name: String
  departments: DepartmentUpdateManyWithoutFacultyInput
}

input FacultyUpdateManyMutationInput {
  name: String
}

input FacultyUpdateOneInput {
  create: FacultyCreateInput
  update: FacultyUpdateDataInput
  upsert: FacultyUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: FacultyWhereUniqueInput
}

input FacultyUpdateOneRequiredWithoutDepartmentsInput {
  create: FacultyCreateWithoutDepartmentsInput
  update: FacultyUpdateWithoutDepartmentsDataInput
  upsert: FacultyUpsertWithoutDepartmentsInput
  connect: FacultyWhereUniqueInput
}

input FacultyUpdateWithoutDepartmentsDataInput {
  name: String
}

input FacultyUpsertNestedInput {
  update: FacultyUpdateDataInput!
  create: FacultyCreateInput!
}

input FacultyUpsertWithoutDepartmentsInput {
  update: FacultyUpdateWithoutDepartmentsDataInput!
  create: FacultyCreateWithoutDepartmentsInput!
}

input FacultyWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  departments_every: DepartmentWhereInput
  departments_some: DepartmentWhereInput
  departments_none: DepartmentWhereInput
  AND: [FacultyWhereInput!]
  OR: [FacultyWhereInput!]
  NOT: [FacultyWhereInput!]
}

input FacultyWhereUniqueInput {
  id: ID
  name: String
}

scalar Long

type Mutation {
  createCourse(data: CourseCreateInput!): Course!
  updateCourse(data: CourseUpdateInput!, where: CourseWhereUniqueInput!): Course
  updateManyCourses(data: CourseUpdateManyMutationInput!, where: CourseWhereInput): BatchPayload!
  upsertCourse(where: CourseWhereUniqueInput!, create: CourseCreateInput!, update: CourseUpdateInput!): Course!
  deleteCourse(where: CourseWhereUniqueInput!): Course
  deleteManyCourses(where: CourseWhereInput): BatchPayload!
  createDepartment(data: DepartmentCreateInput!): Department!
  updateDepartment(data: DepartmentUpdateInput!, where: DepartmentWhereUniqueInput!): Department
  updateManyDepartments(data: DepartmentUpdateManyMutationInput!, where: DepartmentWhereInput): BatchPayload!
  upsertDepartment(where: DepartmentWhereUniqueInput!, create: DepartmentCreateInput!, update: DepartmentUpdateInput!): Department!
  deleteDepartment(where: DepartmentWhereUniqueInput!): Department
  deleteManyDepartments(where: DepartmentWhereInput): BatchPayload!
  createFaculty(data: FacultyCreateInput!): Faculty!
  updateFaculty(data: FacultyUpdateInput!, where: FacultyWhereUniqueInput!): Faculty
  updateManyFaculties(data: FacultyUpdateManyMutationInput!, where: FacultyWhereInput): BatchPayload!
  upsertFaculty(where: FacultyWhereUniqueInput!, create: FacultyCreateInput!, update: FacultyUpdateInput!): Faculty!
  deleteFaculty(where: FacultyWhereUniqueInput!): Faculty
  deleteManyFaculties(where: FacultyWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  course(where: CourseWhereUniqueInput!): Course
  courses(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Course]!
  coursesConnection(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CourseConnection!
  department(where: DepartmentWhereUniqueInput!): Department
  departments(where: DepartmentWhereInput, orderBy: DepartmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Department]!
  departmentsConnection(where: DepartmentWhereInput, orderBy: DepartmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DepartmentConnection!
  faculty(where: FacultyWhereUniqueInput!): Faculty
  faculties(where: FacultyWhereInput, orderBy: FacultyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Faculty]!
  facultiesConnection(where: FacultyWhereInput, orderBy: FacultyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FacultyConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Subscription {
  course(where: CourseSubscriptionWhereInput): CourseSubscriptionPayload
  department(where: DepartmentSubscriptionWhereInput): DepartmentSubscriptionPayload
  faculty(where: FacultySubscriptionWhereInput): FacultySubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  name: String!
  email: String!
  password: String!
  regNo: String!
  gender: String
  department: Department
  faculty: Faculty
  courses(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Course!]
  level: String
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  name: String!
  email: String!
  password: String!
  regNo: String!
  gender: String
  department: DepartmentCreateOneInput
  faculty: FacultyCreateOneInput
  courses: CourseCreateManyWithoutStudentsInput
  level: String
}

input UserCreateManyWithoutCoursesInput {
  create: [UserCreateWithoutCoursesInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateWithoutCoursesInput {
  id: ID
  name: String!
  email: String!
  password: String!
  regNo: String!
  gender: String
  department: DepartmentCreateOneInput
  faculty: FacultyCreateOneInput
  level: String
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  regNo_ASC
  regNo_DESC
  gender_ASC
  gender_DESC
  level_ASC
  level_DESC
}

type UserPreviousValues {
  id: ID!
  name: String!
  email: String!
  password: String!
  regNo: String!
  gender: String
  level: String
}

input UserScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  regNo: String
  regNo_not: String
  regNo_in: [String!]
  regNo_not_in: [String!]
  regNo_lt: String
  regNo_lte: String
  regNo_gt: String
  regNo_gte: String
  regNo_contains: String
  regNo_not_contains: String
  regNo_starts_with: String
  regNo_not_starts_with: String
  regNo_ends_with: String
  regNo_not_ends_with: String
  gender: String
  gender_not: String
  gender_in: [String!]
  gender_not_in: [String!]
  gender_lt: String
  gender_lte: String
  gender_gt: String
  gender_gte: String
  gender_contains: String
  gender_not_contains: String
  gender_starts_with: String
  gender_not_starts_with: String
  gender_ends_with: String
  gender_not_ends_with: String
  level: String
  level_not: String
  level_in: [String!]
  level_not_in: [String!]
  level_lt: String
  level_lte: String
  level_gt: String
  level_gte: String
  level_contains: String
  level_not_contains: String
  level_starts_with: String
  level_not_starts_with: String
  level_ends_with: String
  level_not_ends_with: String
  AND: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  name: String
  email: String
  password: String
  regNo: String
  gender: String
  department: DepartmentUpdateOneInput
  faculty: FacultyUpdateOneInput
  courses: CourseUpdateManyWithoutStudentsInput
  level: String
}

input UserUpdateManyDataInput {
  name: String
  email: String
  password: String
  regNo: String
  gender: String
  level: String
}

input UserUpdateManyMutationInput {
  name: String
  email: String
  password: String
  regNo: String
  gender: String
  level: String
}

input UserUpdateManyWithoutCoursesInput {
  create: [UserCreateWithoutCoursesInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutCoursesInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutCoursesInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput!
  data: UserUpdateManyDataInput!
}

input UserUpdateWithoutCoursesDataInput {
  name: String
  email: String
  password: String
  regNo: String
  gender: String
  department: DepartmentUpdateOneInput
  faculty: FacultyUpdateOneInput
  level: String
}

input UserUpdateWithWhereUniqueWithoutCoursesInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutCoursesDataInput!
}

input UserUpsertWithWhereUniqueWithoutCoursesInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutCoursesDataInput!
  create: UserCreateWithoutCoursesInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  regNo: String
  regNo_not: String
  regNo_in: [String!]
  regNo_not_in: [String!]
  regNo_lt: String
  regNo_lte: String
  regNo_gt: String
  regNo_gte: String
  regNo_contains: String
  regNo_not_contains: String
  regNo_starts_with: String
  regNo_not_starts_with: String
  regNo_ends_with: String
  regNo_not_ends_with: String
  gender: String
  gender_not: String
  gender_in: [String!]
  gender_not_in: [String!]
  gender_lt: String
  gender_lte: String
  gender_gt: String
  gender_gte: String
  gender_contains: String
  gender_not_contains: String
  gender_starts_with: String
  gender_not_starts_with: String
  gender_ends_with: String
  gender_not_ends_with: String
  department: DepartmentWhereInput
  faculty: FacultyWhereInput
  courses_every: CourseWhereInput
  courses_some: CourseWhereInput
  courses_none: CourseWhereInput
  level: String
  level_not: String
  level_in: [String!]
  level_not_in: [String!]
  level_lt: String
  level_lte: String
  level_gt: String
  level_gte: String
  level_contains: String
  level_not_contains: String
  level_starts_with: String
  level_not_starts_with: String
  level_ends_with: String
  level_not_ends_with: String
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`
      }
    