module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.8). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateCourse {
  count: Int!
}

type AggregateCourseHistory {
  count: Int!
}

type AggregateDepartment {
  count: Int!
}

type AggregateFaculty {
  count: Int!
}

type AggregateGrade {
  count: Int!
}

type AggregateLecturer {
  count: Int!
}

type AggregateNextOfKin {
  count: Int!
}

type AggregateResult {
  count: Int!
}

type AggregateSession {
  count: Int!
}

type AggregateStudent {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Course {
  id: ID!
  name: String!
  department: Department!
  creditUnit: Int!
  students(where: StudentWhereInput, orderBy: StudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Student!]
  description: String!
  level: String!
  semester: Semester!
  lecturer: Lecturer
}

type CourseConnection {
  pageInfo: PageInfo!
  edges: [CourseEdge]!
  aggregate: AggregateCourse!
}

input CourseCreateInput {
  id: ID
  name: String!
  department: DepartmentCreateOneWithoutCoursesInput!
  creditUnit: Int!
  students: StudentCreateManyWithoutCoursesInput
  description: String!
  level: String!
  semester: Semester!
  lecturer: LecturerCreateOneWithoutCoursesInput
}

input CourseCreateManyWithoutDepartmentInput {
  create: [CourseCreateWithoutDepartmentInput!]
  connect: [CourseWhereUniqueInput!]
}

input CourseCreateManyWithoutLecturerInput {
  create: [CourseCreateWithoutLecturerInput!]
  connect: [CourseWhereUniqueInput!]
}

input CourseCreateManyWithoutStudentsInput {
  create: [CourseCreateWithoutStudentsInput!]
  connect: [CourseWhereUniqueInput!]
}

input CourseCreateOneInput {
  create: CourseCreateInput
  connect: CourseWhereUniqueInput
}

input CourseCreateWithoutDepartmentInput {
  id: ID
  name: String!
  creditUnit: Int!
  students: StudentCreateManyWithoutCoursesInput
  description: String!
  level: String!
  semester: Semester!
  lecturer: LecturerCreateOneWithoutCoursesInput
}

input CourseCreateWithoutLecturerInput {
  id: ID
  name: String!
  department: DepartmentCreateOneWithoutCoursesInput!
  creditUnit: Int!
  students: StudentCreateManyWithoutCoursesInput
  description: String!
  level: String!
  semester: Semester!
}

input CourseCreateWithoutStudentsInput {
  id: ID
  name: String!
  department: DepartmentCreateOneWithoutCoursesInput!
  creditUnit: Int!
  description: String!
  level: String!
  semester: Semester!
  lecturer: LecturerCreateOneWithoutCoursesInput
}

type CourseEdge {
  node: Course!
  cursor: String!
}

type CourseHistory {
  id: ID!
  student: Student!
  session: Session!
  result: Result!
}

type CourseHistoryConnection {
  pageInfo: PageInfo!
  edges: [CourseHistoryEdge]!
  aggregate: AggregateCourseHistory!
}

input CourseHistoryCreateInput {
  id: ID
  student: StudentCreateOneWithoutHistoryInput!
  session: SessionCreateOneWithoutCourseHistoryInput!
  result: ResultCreateOneInput!
}

input CourseHistoryCreateManyWithoutSessionInput {
  create: [CourseHistoryCreateWithoutSessionInput!]
  connect: [CourseHistoryWhereUniqueInput!]
}

input CourseHistoryCreateManyWithoutStudentInput {
  create: [CourseHistoryCreateWithoutStudentInput!]
  connect: [CourseHistoryWhereUniqueInput!]
}

input CourseHistoryCreateWithoutSessionInput {
  id: ID
  student: StudentCreateOneWithoutHistoryInput!
  result: ResultCreateOneInput!
}

input CourseHistoryCreateWithoutStudentInput {
  id: ID
  session: SessionCreateOneWithoutCourseHistoryInput!
  result: ResultCreateOneInput!
}

type CourseHistoryEdge {
  node: CourseHistory!
  cursor: String!
}

enum CourseHistoryOrderByInput {
  id_ASC
  id_DESC
}

type CourseHistoryPreviousValues {
  id: ID!
}

input CourseHistoryScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  AND: [CourseHistoryScalarWhereInput!]
  OR: [CourseHistoryScalarWhereInput!]
  NOT: [CourseHistoryScalarWhereInput!]
}

type CourseHistorySubscriptionPayload {
  mutation: MutationType!
  node: CourseHistory
  updatedFields: [String!]
  previousValues: CourseHistoryPreviousValues
}

input CourseHistorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CourseHistoryWhereInput
  AND: [CourseHistorySubscriptionWhereInput!]
  OR: [CourseHistorySubscriptionWhereInput!]
  NOT: [CourseHistorySubscriptionWhereInput!]
}

input CourseHistoryUpdateInput {
  student: StudentUpdateOneRequiredWithoutHistoryInput
  session: SessionUpdateOneRequiredWithoutCourseHistoryInput
  result: ResultUpdateOneRequiredInput
}

input CourseHistoryUpdateManyWithoutSessionInput {
  create: [CourseHistoryCreateWithoutSessionInput!]
  delete: [CourseHistoryWhereUniqueInput!]
  connect: [CourseHistoryWhereUniqueInput!]
  set: [CourseHistoryWhereUniqueInput!]
  disconnect: [CourseHistoryWhereUniqueInput!]
  update: [CourseHistoryUpdateWithWhereUniqueWithoutSessionInput!]
  upsert: [CourseHistoryUpsertWithWhereUniqueWithoutSessionInput!]
  deleteMany: [CourseHistoryScalarWhereInput!]
}

input CourseHistoryUpdateManyWithoutStudentInput {
  create: [CourseHistoryCreateWithoutStudentInput!]
  delete: [CourseHistoryWhereUniqueInput!]
  connect: [CourseHistoryWhereUniqueInput!]
  set: [CourseHistoryWhereUniqueInput!]
  disconnect: [CourseHistoryWhereUniqueInput!]
  update: [CourseHistoryUpdateWithWhereUniqueWithoutStudentInput!]
  upsert: [CourseHistoryUpsertWithWhereUniqueWithoutStudentInput!]
  deleteMany: [CourseHistoryScalarWhereInput!]
}

input CourseHistoryUpdateWithoutSessionDataInput {
  student: StudentUpdateOneRequiredWithoutHistoryInput
  result: ResultUpdateOneRequiredInput
}

input CourseHistoryUpdateWithoutStudentDataInput {
  session: SessionUpdateOneRequiredWithoutCourseHistoryInput
  result: ResultUpdateOneRequiredInput
}

input CourseHistoryUpdateWithWhereUniqueWithoutSessionInput {
  where: CourseHistoryWhereUniqueInput!
  data: CourseHistoryUpdateWithoutSessionDataInput!
}

input CourseHistoryUpdateWithWhereUniqueWithoutStudentInput {
  where: CourseHistoryWhereUniqueInput!
  data: CourseHistoryUpdateWithoutStudentDataInput!
}

input CourseHistoryUpsertWithWhereUniqueWithoutSessionInput {
  where: CourseHistoryWhereUniqueInput!
  update: CourseHistoryUpdateWithoutSessionDataInput!
  create: CourseHistoryCreateWithoutSessionInput!
}

input CourseHistoryUpsertWithWhereUniqueWithoutStudentInput {
  where: CourseHistoryWhereUniqueInput!
  update: CourseHistoryUpdateWithoutStudentDataInput!
  create: CourseHistoryCreateWithoutStudentInput!
}

input CourseHistoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  student: StudentWhereInput
  session: SessionWhereInput
  result: ResultWhereInput
  AND: [CourseHistoryWhereInput!]
  OR: [CourseHistoryWhereInput!]
  NOT: [CourseHistoryWhereInput!]
}

input CourseHistoryWhereUniqueInput {
  id: ID
}

enum CourseOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  creditUnit_ASC
  creditUnit_DESC
  description_ASC
  description_DESC
  level_ASC
  level_DESC
  semester_ASC
  semester_DESC
}

type CoursePreviousValues {
  id: ID!
  name: String!
  creditUnit: Int!
  description: String!
  level: String!
  semester: Semester!
}

input CourseScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  creditUnit: Int
  creditUnit_not: Int
  creditUnit_in: [Int!]
  creditUnit_not_in: [Int!]
  creditUnit_lt: Int
  creditUnit_lte: Int
  creditUnit_gt: Int
  creditUnit_gte: Int
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  level: String
  level_not: String
  level_in: [String!]
  level_not_in: [String!]
  level_lt: String
  level_lte: String
  level_gt: String
  level_gte: String
  level_contains: String
  level_not_contains: String
  level_starts_with: String
  level_not_starts_with: String
  level_ends_with: String
  level_not_ends_with: String
  semester: Semester
  semester_not: Semester
  semester_in: [Semester!]
  semester_not_in: [Semester!]
  AND: [CourseScalarWhereInput!]
  OR: [CourseScalarWhereInput!]
  NOT: [CourseScalarWhereInput!]
}

type CourseSubscriptionPayload {
  mutation: MutationType!
  node: Course
  updatedFields: [String!]
  previousValues: CoursePreviousValues
}

input CourseSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CourseWhereInput
  AND: [CourseSubscriptionWhereInput!]
  OR: [CourseSubscriptionWhereInput!]
  NOT: [CourseSubscriptionWhereInput!]
}

input CourseUpdateDataInput {
  name: String
  department: DepartmentUpdateOneRequiredWithoutCoursesInput
  creditUnit: Int
  students: StudentUpdateManyWithoutCoursesInput
  description: String
  level: String
  semester: Semester
  lecturer: LecturerUpdateOneWithoutCoursesInput
}

input CourseUpdateInput {
  name: String
  department: DepartmentUpdateOneRequiredWithoutCoursesInput
  creditUnit: Int
  students: StudentUpdateManyWithoutCoursesInput
  description: String
  level: String
  semester: Semester
  lecturer: LecturerUpdateOneWithoutCoursesInput
}

input CourseUpdateManyDataInput {
  name: String
  creditUnit: Int
  description: String
  level: String
  semester: Semester
}

input CourseUpdateManyMutationInput {
  name: String
  creditUnit: Int
  description: String
  level: String
  semester: Semester
}

input CourseUpdateManyWithoutDepartmentInput {
  create: [CourseCreateWithoutDepartmentInput!]
  delete: [CourseWhereUniqueInput!]
  connect: [CourseWhereUniqueInput!]
  set: [CourseWhereUniqueInput!]
  disconnect: [CourseWhereUniqueInput!]
  update: [CourseUpdateWithWhereUniqueWithoutDepartmentInput!]
  upsert: [CourseUpsertWithWhereUniqueWithoutDepartmentInput!]
  deleteMany: [CourseScalarWhereInput!]
  updateMany: [CourseUpdateManyWithWhereNestedInput!]
}

input CourseUpdateManyWithoutLecturerInput {
  create: [CourseCreateWithoutLecturerInput!]
  delete: [CourseWhereUniqueInput!]
  connect: [CourseWhereUniqueInput!]
  set: [CourseWhereUniqueInput!]
  disconnect: [CourseWhereUniqueInput!]
  update: [CourseUpdateWithWhereUniqueWithoutLecturerInput!]
  upsert: [CourseUpsertWithWhereUniqueWithoutLecturerInput!]
  deleteMany: [CourseScalarWhereInput!]
  updateMany: [CourseUpdateManyWithWhereNestedInput!]
}

input CourseUpdateManyWithoutStudentsInput {
  create: [CourseCreateWithoutStudentsInput!]
  delete: [CourseWhereUniqueInput!]
  connect: [CourseWhereUniqueInput!]
  set: [CourseWhereUniqueInput!]
  disconnect: [CourseWhereUniqueInput!]
  update: [CourseUpdateWithWhereUniqueWithoutStudentsInput!]
  upsert: [CourseUpsertWithWhereUniqueWithoutStudentsInput!]
  deleteMany: [CourseScalarWhereInput!]
  updateMany: [CourseUpdateManyWithWhereNestedInput!]
}

input CourseUpdateManyWithWhereNestedInput {
  where: CourseScalarWhereInput!
  data: CourseUpdateManyDataInput!
}

input CourseUpdateOneRequiredInput {
  create: CourseCreateInput
  update: CourseUpdateDataInput
  upsert: CourseUpsertNestedInput
  connect: CourseWhereUniqueInput
}

input CourseUpdateWithoutDepartmentDataInput {
  name: String
  creditUnit: Int
  students: StudentUpdateManyWithoutCoursesInput
  description: String
  level: String
  semester: Semester
  lecturer: LecturerUpdateOneWithoutCoursesInput
}

input CourseUpdateWithoutLecturerDataInput {
  name: String
  department: DepartmentUpdateOneRequiredWithoutCoursesInput
  creditUnit: Int
  students: StudentUpdateManyWithoutCoursesInput
  description: String
  level: String
  semester: Semester
}

input CourseUpdateWithoutStudentsDataInput {
  name: String
  department: DepartmentUpdateOneRequiredWithoutCoursesInput
  creditUnit: Int
  description: String
  level: String
  semester: Semester
  lecturer: LecturerUpdateOneWithoutCoursesInput
}

input CourseUpdateWithWhereUniqueWithoutDepartmentInput {
  where: CourseWhereUniqueInput!
  data: CourseUpdateWithoutDepartmentDataInput!
}

input CourseUpdateWithWhereUniqueWithoutLecturerInput {
  where: CourseWhereUniqueInput!
  data: CourseUpdateWithoutLecturerDataInput!
}

input CourseUpdateWithWhereUniqueWithoutStudentsInput {
  where: CourseWhereUniqueInput!
  data: CourseUpdateWithoutStudentsDataInput!
}

input CourseUpsertNestedInput {
  update: CourseUpdateDataInput!
  create: CourseCreateInput!
}

input CourseUpsertWithWhereUniqueWithoutDepartmentInput {
  where: CourseWhereUniqueInput!
  update: CourseUpdateWithoutDepartmentDataInput!
  create: CourseCreateWithoutDepartmentInput!
}

input CourseUpsertWithWhereUniqueWithoutLecturerInput {
  where: CourseWhereUniqueInput!
  update: CourseUpdateWithoutLecturerDataInput!
  create: CourseCreateWithoutLecturerInput!
}

input CourseUpsertWithWhereUniqueWithoutStudentsInput {
  where: CourseWhereUniqueInput!
  update: CourseUpdateWithoutStudentsDataInput!
  create: CourseCreateWithoutStudentsInput!
}

input CourseWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  department: DepartmentWhereInput
  creditUnit: Int
  creditUnit_not: Int
  creditUnit_in: [Int!]
  creditUnit_not_in: [Int!]
  creditUnit_lt: Int
  creditUnit_lte: Int
  creditUnit_gt: Int
  creditUnit_gte: Int
  students_every: StudentWhereInput
  students_some: StudentWhereInput
  students_none: StudentWhereInput
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  level: String
  level_not: String
  level_in: [String!]
  level_not_in: [String!]
  level_lt: String
  level_lte: String
  level_gt: String
  level_gte: String
  level_contains: String
  level_not_contains: String
  level_starts_with: String
  level_not_starts_with: String
  level_ends_with: String
  level_not_ends_with: String
  semester: Semester
  semester_not: Semester
  semester_in: [Semester!]
  semester_not_in: [Semester!]
  lecturer: LecturerWhereInput
  AND: [CourseWhereInput!]
  OR: [CourseWhereInput!]
  NOT: [CourseWhereInput!]
}

input CourseWhereUniqueInput {
  id: ID
  name: String
}

type Department {
  id: ID!
  name: String!
  faculty: Faculty!
  courses(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Course!]
  students(where: StudentWhereInput, orderBy: StudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Student!]
}

type DepartmentConnection {
  pageInfo: PageInfo!
  edges: [DepartmentEdge]!
  aggregate: AggregateDepartment!
}

input DepartmentCreateInput {
  id: ID
  name: String!
  faculty: FacultyCreateOneWithoutDepartmentsInput!
  courses: CourseCreateManyWithoutDepartmentInput
  students: StudentCreateManyWithoutDepartmentInput
}

input DepartmentCreateManyWithoutFacultyInput {
  create: [DepartmentCreateWithoutFacultyInput!]
  connect: [DepartmentWhereUniqueInput!]
}

input DepartmentCreateOneWithoutCoursesInput {
  create: DepartmentCreateWithoutCoursesInput
  connect: DepartmentWhereUniqueInput
}

input DepartmentCreateOneWithoutStudentsInput {
  create: DepartmentCreateWithoutStudentsInput
  connect: DepartmentWhereUniqueInput
}

input DepartmentCreateWithoutCoursesInput {
  id: ID
  name: String!
  faculty: FacultyCreateOneWithoutDepartmentsInput!
  students: StudentCreateManyWithoutDepartmentInput
}

input DepartmentCreateWithoutFacultyInput {
  id: ID
  name: String!
  courses: CourseCreateManyWithoutDepartmentInput
  students: StudentCreateManyWithoutDepartmentInput
}

input DepartmentCreateWithoutStudentsInput {
  id: ID
  name: String!
  faculty: FacultyCreateOneWithoutDepartmentsInput!
  courses: CourseCreateManyWithoutDepartmentInput
}

type DepartmentEdge {
  node: Department!
  cursor: String!
}

enum DepartmentOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type DepartmentPreviousValues {
  id: ID!
  name: String!
}

input DepartmentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [DepartmentScalarWhereInput!]
  OR: [DepartmentScalarWhereInput!]
  NOT: [DepartmentScalarWhereInput!]
}

type DepartmentSubscriptionPayload {
  mutation: MutationType!
  node: Department
  updatedFields: [String!]
  previousValues: DepartmentPreviousValues
}

input DepartmentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DepartmentWhereInput
  AND: [DepartmentSubscriptionWhereInput!]
  OR: [DepartmentSubscriptionWhereInput!]
  NOT: [DepartmentSubscriptionWhereInput!]
}

input DepartmentUpdateInput {
  name: String
  faculty: FacultyUpdateOneRequiredWithoutDepartmentsInput
  courses: CourseUpdateManyWithoutDepartmentInput
  students: StudentUpdateManyWithoutDepartmentInput
}

input DepartmentUpdateManyDataInput {
  name: String
}

input DepartmentUpdateManyMutationInput {
  name: String
}

input DepartmentUpdateManyWithoutFacultyInput {
  create: [DepartmentCreateWithoutFacultyInput!]
  delete: [DepartmentWhereUniqueInput!]
  connect: [DepartmentWhereUniqueInput!]
  set: [DepartmentWhereUniqueInput!]
  disconnect: [DepartmentWhereUniqueInput!]
  update: [DepartmentUpdateWithWhereUniqueWithoutFacultyInput!]
  upsert: [DepartmentUpsertWithWhereUniqueWithoutFacultyInput!]
  deleteMany: [DepartmentScalarWhereInput!]
  updateMany: [DepartmentUpdateManyWithWhereNestedInput!]
}

input DepartmentUpdateManyWithWhereNestedInput {
  where: DepartmentScalarWhereInput!
  data: DepartmentUpdateManyDataInput!
}

input DepartmentUpdateOneRequiredWithoutCoursesInput {
  create: DepartmentCreateWithoutCoursesInput
  update: DepartmentUpdateWithoutCoursesDataInput
  upsert: DepartmentUpsertWithoutCoursesInput
  connect: DepartmentWhereUniqueInput
}

input DepartmentUpdateOneWithoutStudentsInput {
  create: DepartmentCreateWithoutStudentsInput
  update: DepartmentUpdateWithoutStudentsDataInput
  upsert: DepartmentUpsertWithoutStudentsInput
  delete: Boolean
  disconnect: Boolean
  connect: DepartmentWhereUniqueInput
}

input DepartmentUpdateWithoutCoursesDataInput {
  name: String
  faculty: FacultyUpdateOneRequiredWithoutDepartmentsInput
  students: StudentUpdateManyWithoutDepartmentInput
}

input DepartmentUpdateWithoutFacultyDataInput {
  name: String
  courses: CourseUpdateManyWithoutDepartmentInput
  students: StudentUpdateManyWithoutDepartmentInput
}

input DepartmentUpdateWithoutStudentsDataInput {
  name: String
  faculty: FacultyUpdateOneRequiredWithoutDepartmentsInput
  courses: CourseUpdateManyWithoutDepartmentInput
}

input DepartmentUpdateWithWhereUniqueWithoutFacultyInput {
  where: DepartmentWhereUniqueInput!
  data: DepartmentUpdateWithoutFacultyDataInput!
}

input DepartmentUpsertWithoutCoursesInput {
  update: DepartmentUpdateWithoutCoursesDataInput!
  create: DepartmentCreateWithoutCoursesInput!
}

input DepartmentUpsertWithoutStudentsInput {
  update: DepartmentUpdateWithoutStudentsDataInput!
  create: DepartmentCreateWithoutStudentsInput!
}

input DepartmentUpsertWithWhereUniqueWithoutFacultyInput {
  where: DepartmentWhereUniqueInput!
  update: DepartmentUpdateWithoutFacultyDataInput!
  create: DepartmentCreateWithoutFacultyInput!
}

input DepartmentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  faculty: FacultyWhereInput
  courses_every: CourseWhereInput
  courses_some: CourseWhereInput
  courses_none: CourseWhereInput
  students_every: StudentWhereInput
  students_some: StudentWhereInput
  students_none: StudentWhereInput
  AND: [DepartmentWhereInput!]
  OR: [DepartmentWhereInput!]
  NOT: [DepartmentWhereInput!]
}

input DepartmentWhereUniqueInput {
  id: ID
  name: String
}

type Faculty {
  id: ID!
  name: String!
  departments(where: DepartmentWhereInput, orderBy: DepartmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Department!]
}

type FacultyConnection {
  pageInfo: PageInfo!
  edges: [FacultyEdge]!
  aggregate: AggregateFaculty!
}

input FacultyCreateInput {
  id: ID
  name: String!
  departments: DepartmentCreateManyWithoutFacultyInput
}

input FacultyCreateOneInput {
  create: FacultyCreateInput
  connect: FacultyWhereUniqueInput
}

input FacultyCreateOneWithoutDepartmentsInput {
  create: FacultyCreateWithoutDepartmentsInput
  connect: FacultyWhereUniqueInput
}

input FacultyCreateWithoutDepartmentsInput {
  id: ID
  name: String!
}

type FacultyEdge {
  node: Faculty!
  cursor: String!
}

enum FacultyOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type FacultyPreviousValues {
  id: ID!
  name: String!
}

type FacultySubscriptionPayload {
  mutation: MutationType!
  node: Faculty
  updatedFields: [String!]
  previousValues: FacultyPreviousValues
}

input FacultySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FacultyWhereInput
  AND: [FacultySubscriptionWhereInput!]
  OR: [FacultySubscriptionWhereInput!]
  NOT: [FacultySubscriptionWhereInput!]
}

input FacultyUpdateDataInput {
  name: String
  departments: DepartmentUpdateManyWithoutFacultyInput
}

input FacultyUpdateInput {
  name: String
  departments: DepartmentUpdateManyWithoutFacultyInput
}

input FacultyUpdateManyMutationInput {
  name: String
}

input FacultyUpdateOneInput {
  create: FacultyCreateInput
  update: FacultyUpdateDataInput
  upsert: FacultyUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: FacultyWhereUniqueInput
}

input FacultyUpdateOneRequiredWithoutDepartmentsInput {
  create: FacultyCreateWithoutDepartmentsInput
  update: FacultyUpdateWithoutDepartmentsDataInput
  upsert: FacultyUpsertWithoutDepartmentsInput
  connect: FacultyWhereUniqueInput
}

input FacultyUpdateWithoutDepartmentsDataInput {
  name: String
}

input FacultyUpsertNestedInput {
  update: FacultyUpdateDataInput!
  create: FacultyCreateInput!
}

input FacultyUpsertWithoutDepartmentsInput {
  update: FacultyUpdateWithoutDepartmentsDataInput!
  create: FacultyCreateWithoutDepartmentsInput!
}

input FacultyWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  departments_every: DepartmentWhereInput
  departments_some: DepartmentWhereInput
  departments_none: DepartmentWhereInput
  AND: [FacultyWhereInput!]
  OR: [FacultyWhereInput!]
  NOT: [FacultyWhereInput!]
}

input FacultyWhereUniqueInput {
  id: ID
  name: String
}

type Grade {
  id: ID!
  session: Session!
  semester: Semester!
  student: Student!
  course: Course!
  test: Int
  exam: Int
  grade: GradeType!
  cleared: Boolean!
}

type GradeConnection {
  pageInfo: PageInfo!
  edges: [GradeEdge]!
  aggregate: AggregateGrade!
}

input GradeCreateInput {
  id: ID
  session: SessionCreateOneInput!
  semester: Semester!
  student: StudentCreateOneInput!
  course: CourseCreateOneInput!
  test: Int
  exam: Int
  grade: GradeType!
  cleared: Boolean!
}

input GradeCreateManyInput {
  create: [GradeCreateInput!]
  connect: [GradeWhereUniqueInput!]
}

type GradeEdge {
  node: Grade!
  cursor: String!
}

enum GradeOrderByInput {
  id_ASC
  id_DESC
  semester_ASC
  semester_DESC
  test_ASC
  test_DESC
  exam_ASC
  exam_DESC
  grade_ASC
  grade_DESC
  cleared_ASC
  cleared_DESC
}

type GradePreviousValues {
  id: ID!
  semester: Semester!
  test: Int
  exam: Int
  grade: GradeType!
  cleared: Boolean!
}

input GradeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  semester: Semester
  semester_not: Semester
  semester_in: [Semester!]
  semester_not_in: [Semester!]
  test: Int
  test_not: Int
  test_in: [Int!]
  test_not_in: [Int!]
  test_lt: Int
  test_lte: Int
  test_gt: Int
  test_gte: Int
  exam: Int
  exam_not: Int
  exam_in: [Int!]
  exam_not_in: [Int!]
  exam_lt: Int
  exam_lte: Int
  exam_gt: Int
  exam_gte: Int
  grade: GradeType
  grade_not: GradeType
  grade_in: [GradeType!]
  grade_not_in: [GradeType!]
  cleared: Boolean
  cleared_not: Boolean
  AND: [GradeScalarWhereInput!]
  OR: [GradeScalarWhereInput!]
  NOT: [GradeScalarWhereInput!]
}

type GradeSubscriptionPayload {
  mutation: MutationType!
  node: Grade
  updatedFields: [String!]
  previousValues: GradePreviousValues
}

input GradeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: GradeWhereInput
  AND: [GradeSubscriptionWhereInput!]
  OR: [GradeSubscriptionWhereInput!]
  NOT: [GradeSubscriptionWhereInput!]
}

enum GradeType {
  A
  B
  C
  D
  E
  F
}

input GradeUpdateDataInput {
  session: SessionUpdateOneRequiredInput
  semester: Semester
  student: StudentUpdateOneRequiredInput
  course: CourseUpdateOneRequiredInput
  test: Int
  exam: Int
  grade: GradeType
  cleared: Boolean
}

input GradeUpdateInput {
  session: SessionUpdateOneRequiredInput
  semester: Semester
  student: StudentUpdateOneRequiredInput
  course: CourseUpdateOneRequiredInput
  test: Int
  exam: Int
  grade: GradeType
  cleared: Boolean
}

input GradeUpdateManyDataInput {
  semester: Semester
  test: Int
  exam: Int
  grade: GradeType
  cleared: Boolean
}

input GradeUpdateManyInput {
  create: [GradeCreateInput!]
  update: [GradeUpdateWithWhereUniqueNestedInput!]
  upsert: [GradeUpsertWithWhereUniqueNestedInput!]
  delete: [GradeWhereUniqueInput!]
  connect: [GradeWhereUniqueInput!]
  set: [GradeWhereUniqueInput!]
  disconnect: [GradeWhereUniqueInput!]
  deleteMany: [GradeScalarWhereInput!]
  updateMany: [GradeUpdateManyWithWhereNestedInput!]
}

input GradeUpdateManyMutationInput {
  semester: Semester
  test: Int
  exam: Int
  grade: GradeType
  cleared: Boolean
}

input GradeUpdateManyWithWhereNestedInput {
  where: GradeScalarWhereInput!
  data: GradeUpdateManyDataInput!
}

input GradeUpdateWithWhereUniqueNestedInput {
  where: GradeWhereUniqueInput!
  data: GradeUpdateDataInput!
}

input GradeUpsertWithWhereUniqueNestedInput {
  where: GradeWhereUniqueInput!
  update: GradeUpdateDataInput!
  create: GradeCreateInput!
}

input GradeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  session: SessionWhereInput
  semester: Semester
  semester_not: Semester
  semester_in: [Semester!]
  semester_not_in: [Semester!]
  student: StudentWhereInput
  course: CourseWhereInput
  test: Int
  test_not: Int
  test_in: [Int!]
  test_not_in: [Int!]
  test_lt: Int
  test_lte: Int
  test_gt: Int
  test_gte: Int
  exam: Int
  exam_not: Int
  exam_in: [Int!]
  exam_not_in: [Int!]
  exam_lt: Int
  exam_lte: Int
  exam_gt: Int
  exam_gte: Int
  grade: GradeType
  grade_not: GradeType
  grade_in: [GradeType!]
  grade_not_in: [GradeType!]
  cleared: Boolean
  cleared_not: Boolean
  AND: [GradeWhereInput!]
  OR: [GradeWhereInput!]
  NOT: [GradeWhereInput!]
}

input GradeWhereUniqueInput {
  id: ID
}

type Lecturer {
  id: ID!
  name: String!
  role: UserRole!
  courses(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Course!]
  email: String!
  password: String!
}

type LecturerConnection {
  pageInfo: PageInfo!
  edges: [LecturerEdge]!
  aggregate: AggregateLecturer!
}

input LecturerCreateInput {
  id: ID
  name: String!
  role: UserRole
  courses: CourseCreateManyWithoutLecturerInput
  email: String!
  password: String!
}

input LecturerCreateOneWithoutCoursesInput {
  create: LecturerCreateWithoutCoursesInput
  connect: LecturerWhereUniqueInput
}

input LecturerCreateWithoutCoursesInput {
  id: ID
  name: String!
  role: UserRole
  email: String!
  password: String!
}

type LecturerEdge {
  node: Lecturer!
  cursor: String!
}

enum LecturerOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  role_ASC
  role_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
}

type LecturerPreviousValues {
  id: ID!
  name: String!
  role: UserRole!
  email: String!
  password: String!
}

type LecturerSubscriptionPayload {
  mutation: MutationType!
  node: Lecturer
  updatedFields: [String!]
  previousValues: LecturerPreviousValues
}

input LecturerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: LecturerWhereInput
  AND: [LecturerSubscriptionWhereInput!]
  OR: [LecturerSubscriptionWhereInput!]
  NOT: [LecturerSubscriptionWhereInput!]
}

input LecturerUpdateInput {
  name: String
  role: UserRole
  courses: CourseUpdateManyWithoutLecturerInput
  email: String
  password: String
}

input LecturerUpdateManyMutationInput {
  name: String
  role: UserRole
  email: String
  password: String
}

input LecturerUpdateOneWithoutCoursesInput {
  create: LecturerCreateWithoutCoursesInput
  update: LecturerUpdateWithoutCoursesDataInput
  upsert: LecturerUpsertWithoutCoursesInput
  delete: Boolean
  disconnect: Boolean
  connect: LecturerWhereUniqueInput
}

input LecturerUpdateWithoutCoursesDataInput {
  name: String
  role: UserRole
  email: String
  password: String
}

input LecturerUpsertWithoutCoursesInput {
  update: LecturerUpdateWithoutCoursesDataInput!
  create: LecturerCreateWithoutCoursesInput!
}

input LecturerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  role: UserRole
  role_not: UserRole
  role_in: [UserRole!]
  role_not_in: [UserRole!]
  courses_every: CourseWhereInput
  courses_some: CourseWhereInput
  courses_none: CourseWhereInput
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  AND: [LecturerWhereInput!]
  OR: [LecturerWhereInput!]
  NOT: [LecturerWhereInput!]
}

input LecturerWhereUniqueInput {
  id: ID
  email: String
}

scalar Long

type Mutation {
  createCourse(data: CourseCreateInput!): Course!
  updateCourse(data: CourseUpdateInput!, where: CourseWhereUniqueInput!): Course
  updateManyCourses(data: CourseUpdateManyMutationInput!, where: CourseWhereInput): BatchPayload!
  upsertCourse(where: CourseWhereUniqueInput!, create: CourseCreateInput!, update: CourseUpdateInput!): Course!
  deleteCourse(where: CourseWhereUniqueInput!): Course
  deleteManyCourses(where: CourseWhereInput): BatchPayload!
  createCourseHistory(data: CourseHistoryCreateInput!): CourseHistory!
  updateCourseHistory(data: CourseHistoryUpdateInput!, where: CourseHistoryWhereUniqueInput!): CourseHistory
  upsertCourseHistory(where: CourseHistoryWhereUniqueInput!, create: CourseHistoryCreateInput!, update: CourseHistoryUpdateInput!): CourseHistory!
  deleteCourseHistory(where: CourseHistoryWhereUniqueInput!): CourseHistory
  deleteManyCourseHistories(where: CourseHistoryWhereInput): BatchPayload!
  createDepartment(data: DepartmentCreateInput!): Department!
  updateDepartment(data: DepartmentUpdateInput!, where: DepartmentWhereUniqueInput!): Department
  updateManyDepartments(data: DepartmentUpdateManyMutationInput!, where: DepartmentWhereInput): BatchPayload!
  upsertDepartment(where: DepartmentWhereUniqueInput!, create: DepartmentCreateInput!, update: DepartmentUpdateInput!): Department!
  deleteDepartment(where: DepartmentWhereUniqueInput!): Department
  deleteManyDepartments(where: DepartmentWhereInput): BatchPayload!
  createFaculty(data: FacultyCreateInput!): Faculty!
  updateFaculty(data: FacultyUpdateInput!, where: FacultyWhereUniqueInput!): Faculty
  updateManyFaculties(data: FacultyUpdateManyMutationInput!, where: FacultyWhereInput): BatchPayload!
  upsertFaculty(where: FacultyWhereUniqueInput!, create: FacultyCreateInput!, update: FacultyUpdateInput!): Faculty!
  deleteFaculty(where: FacultyWhereUniqueInput!): Faculty
  deleteManyFaculties(where: FacultyWhereInput): BatchPayload!
  createGrade(data: GradeCreateInput!): Grade!
  updateGrade(data: GradeUpdateInput!, where: GradeWhereUniqueInput!): Grade
  updateManyGrades(data: GradeUpdateManyMutationInput!, where: GradeWhereInput): BatchPayload!
  upsertGrade(where: GradeWhereUniqueInput!, create: GradeCreateInput!, update: GradeUpdateInput!): Grade!
  deleteGrade(where: GradeWhereUniqueInput!): Grade
  deleteManyGrades(where: GradeWhereInput): BatchPayload!
  createLecturer(data: LecturerCreateInput!): Lecturer!
  updateLecturer(data: LecturerUpdateInput!, where: LecturerWhereUniqueInput!): Lecturer
  updateManyLecturers(data: LecturerUpdateManyMutationInput!, where: LecturerWhereInput): BatchPayload!
  upsertLecturer(where: LecturerWhereUniqueInput!, create: LecturerCreateInput!, update: LecturerUpdateInput!): Lecturer!
  deleteLecturer(where: LecturerWhereUniqueInput!): Lecturer
  deleteManyLecturers(where: LecturerWhereInput): BatchPayload!
  createNextOfKin(data: NextOfKinCreateInput!): NextOfKin!
  updateNextOfKin(data: NextOfKinUpdateInput!, where: NextOfKinWhereUniqueInput!): NextOfKin
  updateManyNextOfKins(data: NextOfKinUpdateManyMutationInput!, where: NextOfKinWhereInput): BatchPayload!
  upsertNextOfKin(where: NextOfKinWhereUniqueInput!, create: NextOfKinCreateInput!, update: NextOfKinUpdateInput!): NextOfKin!
  deleteNextOfKin(where: NextOfKinWhereUniqueInput!): NextOfKin
  deleteManyNextOfKins(where: NextOfKinWhereInput): BatchPayload!
  createResult(data: ResultCreateInput!): Result!
  updateResult(data: ResultUpdateInput!, where: ResultWhereUniqueInput!): Result
  updateManyResults(data: ResultUpdateManyMutationInput!, where: ResultWhereInput): BatchPayload!
  upsertResult(where: ResultWhereUniqueInput!, create: ResultCreateInput!, update: ResultUpdateInput!): Result!
  deleteResult(where: ResultWhereUniqueInput!): Result
  deleteManyResults(where: ResultWhereInput): BatchPayload!
  createSession(data: SessionCreateInput!): Session!
  updateSession(data: SessionUpdateInput!, where: SessionWhereUniqueInput!): Session
  updateManySessions(data: SessionUpdateManyMutationInput!, where: SessionWhereInput): BatchPayload!
  upsertSession(where: SessionWhereUniqueInput!, create: SessionCreateInput!, update: SessionUpdateInput!): Session!
  deleteSession(where: SessionWhereUniqueInput!): Session
  deleteManySessions(where: SessionWhereInput): BatchPayload!
  createStudent(data: StudentCreateInput!): Student!
  updateStudent(data: StudentUpdateInput!, where: StudentWhereUniqueInput!): Student
  updateManyStudents(data: StudentUpdateManyMutationInput!, where: StudentWhereInput): BatchPayload!
  upsertStudent(where: StudentWhereUniqueInput!, create: StudentCreateInput!, update: StudentUpdateInput!): Student!
  deleteStudent(where: StudentWhereUniqueInput!): Student
  deleteManyStudents(where: StudentWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

type NextOfKin {
  id: ID!
  name: String!
  student: Student!
  email: String!
  address: String!
  phone: String!
  relationship: String!
}

type NextOfKinConnection {
  pageInfo: PageInfo!
  edges: [NextOfKinEdge]!
  aggregate: AggregateNextOfKin!
}

input NextOfKinCreateInput {
  id: ID
  name: String!
  student: StudentCreateOneWithoutNextOfKinInput!
  email: String!
  address: String!
  phone: String!
  relationship: String!
}

input NextOfKinCreateOneWithoutStudentInput {
  create: NextOfKinCreateWithoutStudentInput
  connect: NextOfKinWhereUniqueInput
}

input NextOfKinCreateWithoutStudentInput {
  id: ID
  name: String!
  email: String!
  address: String!
  phone: String!
  relationship: String!
}

type NextOfKinEdge {
  node: NextOfKin!
  cursor: String!
}

enum NextOfKinOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
  address_ASC
  address_DESC
  phone_ASC
  phone_DESC
  relationship_ASC
  relationship_DESC
}

type NextOfKinPreviousValues {
  id: ID!
  name: String!
  email: String!
  address: String!
  phone: String!
  relationship: String!
}

type NextOfKinSubscriptionPayload {
  mutation: MutationType!
  node: NextOfKin
  updatedFields: [String!]
  previousValues: NextOfKinPreviousValues
}

input NextOfKinSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NextOfKinWhereInput
  AND: [NextOfKinSubscriptionWhereInput!]
  OR: [NextOfKinSubscriptionWhereInput!]
  NOT: [NextOfKinSubscriptionWhereInput!]
}

input NextOfKinUpdateInput {
  name: String
  student: StudentUpdateOneRequiredWithoutNextOfKinInput
  email: String
  address: String
  phone: String
  relationship: String
}

input NextOfKinUpdateManyMutationInput {
  name: String
  email: String
  address: String
  phone: String
  relationship: String
}

input NextOfKinUpdateOneWithoutStudentInput {
  create: NextOfKinCreateWithoutStudentInput
  update: NextOfKinUpdateWithoutStudentDataInput
  upsert: NextOfKinUpsertWithoutStudentInput
  delete: Boolean
  disconnect: Boolean
  connect: NextOfKinWhereUniqueInput
}

input NextOfKinUpdateWithoutStudentDataInput {
  name: String
  email: String
  address: String
  phone: String
  relationship: String
}

input NextOfKinUpsertWithoutStudentInput {
  update: NextOfKinUpdateWithoutStudentDataInput!
  create: NextOfKinCreateWithoutStudentInput!
}

input NextOfKinWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  student: StudentWhereInput
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  relationship: String
  relationship_not: String
  relationship_in: [String!]
  relationship_not_in: [String!]
  relationship_lt: String
  relationship_lte: String
  relationship_gt: String
  relationship_gte: String
  relationship_contains: String
  relationship_not_contains: String
  relationship_starts_with: String
  relationship_not_starts_with: String
  relationship_ends_with: String
  relationship_not_ends_with: String
  AND: [NextOfKinWhereInput!]
  OR: [NextOfKinWhereInput!]
  NOT: [NextOfKinWhereInput!]
}

input NextOfKinWhereUniqueInput {
  id: ID
  email: String
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  course(where: CourseWhereUniqueInput!): Course
  courses(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Course]!
  coursesConnection(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CourseConnection!
  courseHistory(where: CourseHistoryWhereUniqueInput!): CourseHistory
  courseHistories(where: CourseHistoryWhereInput, orderBy: CourseHistoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CourseHistory]!
  courseHistoriesConnection(where: CourseHistoryWhereInput, orderBy: CourseHistoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CourseHistoryConnection!
  department(where: DepartmentWhereUniqueInput!): Department
  departments(where: DepartmentWhereInput, orderBy: DepartmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Department]!
  departmentsConnection(where: DepartmentWhereInput, orderBy: DepartmentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DepartmentConnection!
  faculty(where: FacultyWhereUniqueInput!): Faculty
  faculties(where: FacultyWhereInput, orderBy: FacultyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Faculty]!
  facultiesConnection(where: FacultyWhereInput, orderBy: FacultyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FacultyConnection!
  grade(where: GradeWhereUniqueInput!): Grade
  grades(where: GradeWhereInput, orderBy: GradeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Grade]!
  gradesConnection(where: GradeWhereInput, orderBy: GradeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): GradeConnection!
  lecturer(where: LecturerWhereUniqueInput!): Lecturer
  lecturers(where: LecturerWhereInput, orderBy: LecturerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Lecturer]!
  lecturersConnection(where: LecturerWhereInput, orderBy: LecturerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): LecturerConnection!
  nextOfKin(where: NextOfKinWhereUniqueInput!): NextOfKin
  nextOfKins(where: NextOfKinWhereInput, orderBy: NextOfKinOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [NextOfKin]!
  nextOfKinsConnection(where: NextOfKinWhereInput, orderBy: NextOfKinOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NextOfKinConnection!
  result(where: ResultWhereUniqueInput!): Result
  results(where: ResultWhereInput, orderBy: ResultOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Result]!
  resultsConnection(where: ResultWhereInput, orderBy: ResultOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ResultConnection!
  session(where: SessionWhereUniqueInput!): Session
  sessions(where: SessionWhereInput, orderBy: SessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Session]!
  sessionsConnection(where: SessionWhereInput, orderBy: SessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SessionConnection!
  student(where: StudentWhereUniqueInput!): Student
  students(where: StudentWhereInput, orderBy: StudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Student]!
  studentsConnection(where: StudentWhereInput, orderBy: StudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): StudentConnection!
  node(id: ID!): Node
}

type Result {
  id: ID!
  students: Student!
  grades(where: GradeWhereInput, orderBy: GradeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Grade!]
  semester: Semester!
}

type ResultConnection {
  pageInfo: PageInfo!
  edges: [ResultEdge]!
  aggregate: AggregateResult!
}

input ResultCreateInput {
  id: ID
  students: StudentCreateOneInput!
  grades: GradeCreateManyInput
  semester: Semester!
}

input ResultCreateOneInput {
  create: ResultCreateInput
  connect: ResultWhereUniqueInput
}

type ResultEdge {
  node: Result!
  cursor: String!
}

enum ResultOrderByInput {
  id_ASC
  id_DESC
  semester_ASC
  semester_DESC
}

type ResultPreviousValues {
  id: ID!
  semester: Semester!
}

type ResultSubscriptionPayload {
  mutation: MutationType!
  node: Result
  updatedFields: [String!]
  previousValues: ResultPreviousValues
}

input ResultSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ResultWhereInput
  AND: [ResultSubscriptionWhereInput!]
  OR: [ResultSubscriptionWhereInput!]
  NOT: [ResultSubscriptionWhereInput!]
}

input ResultUpdateDataInput {
  students: StudentUpdateOneRequiredInput
  grades: GradeUpdateManyInput
  semester: Semester
}

input ResultUpdateInput {
  students: StudentUpdateOneRequiredInput
  grades: GradeUpdateManyInput
  semester: Semester
}

input ResultUpdateManyMutationInput {
  semester: Semester
}

input ResultUpdateOneRequiredInput {
  create: ResultCreateInput
  update: ResultUpdateDataInput
  upsert: ResultUpsertNestedInput
  connect: ResultWhereUniqueInput
}

input ResultUpsertNestedInput {
  update: ResultUpdateDataInput!
  create: ResultCreateInput!
}

input ResultWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  students: StudentWhereInput
  grades_every: GradeWhereInput
  grades_some: GradeWhereInput
  grades_none: GradeWhereInput
  semester: Semester
  semester_not: Semester
  semester_in: [Semester!]
  semester_not_in: [Semester!]
  AND: [ResultWhereInput!]
  OR: [ResultWhereInput!]
  NOT: [ResultWhereInput!]
}

input ResultWhereUniqueInput {
  id: ID
}

enum Semester {
  FIRST_SEMESTER
  SECOND_SEMESTER
}

type Session {
  id: ID!
  year: String!
  students(where: StudentWhereInput, orderBy: StudentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Student!]
  courseHistory(where: CourseHistoryWhereInput, orderBy: CourseHistoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CourseHistory!]
}

type SessionConnection {
  pageInfo: PageInfo!
  edges: [SessionEdge]!
  aggregate: AggregateSession!
}

input SessionCreateInput {
  id: ID
  year: String!
  students: StudentCreateManyInput
  courseHistory: CourseHistoryCreateManyWithoutSessionInput
}

input SessionCreateOneInput {
  create: SessionCreateInput
  connect: SessionWhereUniqueInput
}

input SessionCreateOneWithoutCourseHistoryInput {
  create: SessionCreateWithoutCourseHistoryInput
  connect: SessionWhereUniqueInput
}

input SessionCreateWithoutCourseHistoryInput {
  id: ID
  year: String!
  students: StudentCreateManyInput
}

type SessionEdge {
  node: Session!
  cursor: String!
}

enum SessionOrderByInput {
  id_ASC
  id_DESC
  year_ASC
  year_DESC
}

type SessionPreviousValues {
  id: ID!
  year: String!
}

type SessionSubscriptionPayload {
  mutation: MutationType!
  node: Session
  updatedFields: [String!]
  previousValues: SessionPreviousValues
}

input SessionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SessionWhereInput
  AND: [SessionSubscriptionWhereInput!]
  OR: [SessionSubscriptionWhereInput!]
  NOT: [SessionSubscriptionWhereInput!]
}

input SessionUpdateDataInput {
  year: String
  students: StudentUpdateManyInput
  courseHistory: CourseHistoryUpdateManyWithoutSessionInput
}

input SessionUpdateInput {
  year: String
  students: StudentUpdateManyInput
  courseHistory: CourseHistoryUpdateManyWithoutSessionInput
}

input SessionUpdateManyMutationInput {
  year: String
}

input SessionUpdateOneRequiredInput {
  create: SessionCreateInput
  update: SessionUpdateDataInput
  upsert: SessionUpsertNestedInput
  connect: SessionWhereUniqueInput
}

input SessionUpdateOneRequiredWithoutCourseHistoryInput {
  create: SessionCreateWithoutCourseHistoryInput
  update: SessionUpdateWithoutCourseHistoryDataInput
  upsert: SessionUpsertWithoutCourseHistoryInput
  connect: SessionWhereUniqueInput
}

input SessionUpdateWithoutCourseHistoryDataInput {
  year: String
  students: StudentUpdateManyInput
}

input SessionUpsertNestedInput {
  update: SessionUpdateDataInput!
  create: SessionCreateInput!
}

input SessionUpsertWithoutCourseHistoryInput {
  update: SessionUpdateWithoutCourseHistoryDataInput!
  create: SessionCreateWithoutCourseHistoryInput!
}

input SessionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  year: String
  year_not: String
  year_in: [String!]
  year_not_in: [String!]
  year_lt: String
  year_lte: String
  year_gt: String
  year_gte: String
  year_contains: String
  year_not_contains: String
  year_starts_with: String
  year_not_starts_with: String
  year_ends_with: String
  year_not_ends_with: String
  students_every: StudentWhereInput
  students_some: StudentWhereInput
  students_none: StudentWhereInput
  courseHistory_every: CourseHistoryWhereInput
  courseHistory_some: CourseHistoryWhereInput
  courseHistory_none: CourseHistoryWhereInput
  AND: [SessionWhereInput!]
  OR: [SessionWhereInput!]
  NOT: [SessionWhereInput!]
}

input SessionWhereUniqueInput {
  id: ID
}

type Student {
  id: ID!
  name: String!
  email: String!
  regNo: String!
  gender: String
  department: Department
  faculty: Faculty
  courses(where: CourseWhereInput, orderBy: CourseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Course!]
  level: String
  phone: String
  address: String
  image: String
  role: UserRole!
  history(where: CourseHistoryWhereInput, orderBy: CourseHistoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CourseHistory!]
  graduated: Boolean
  password: String!
  nextOfKin: NextOfKin
}

type StudentConnection {
  pageInfo: PageInfo!
  edges: [StudentEdge]!
  aggregate: AggregateStudent!
}

input StudentCreateInput {
  id: ID
  name: String!
  email: String!
  regNo: String!
  gender: String
  department: DepartmentCreateOneWithoutStudentsInput
  faculty: FacultyCreateOneInput
  courses: CourseCreateManyWithoutStudentsInput
  level: String
  phone: String
  address: String
  image: String
  role: UserRole
  history: CourseHistoryCreateManyWithoutStudentInput
  graduated: Boolean
  password: String!
  nextOfKin: NextOfKinCreateOneWithoutStudentInput
}

input StudentCreateManyInput {
  create: [StudentCreateInput!]
  connect: [StudentWhereUniqueInput!]
}

input StudentCreateManyWithoutCoursesInput {
  create: [StudentCreateWithoutCoursesInput!]
  connect: [StudentWhereUniqueInput!]
}

input StudentCreateManyWithoutDepartmentInput {
  create: [StudentCreateWithoutDepartmentInput!]
  connect: [StudentWhereUniqueInput!]
}

input StudentCreateOneInput {
  create: StudentCreateInput
  connect: StudentWhereUniqueInput
}

input StudentCreateOneWithoutHistoryInput {
  create: StudentCreateWithoutHistoryInput
  connect: StudentWhereUniqueInput
}

input StudentCreateOneWithoutNextOfKinInput {
  create: StudentCreateWithoutNextOfKinInput
  connect: StudentWhereUniqueInput
}

input StudentCreateWithoutCoursesInput {
  id: ID
  name: String!
  email: String!
  regNo: String!
  gender: String
  department: DepartmentCreateOneWithoutStudentsInput
  faculty: FacultyCreateOneInput
  level: String
  phone: String
  address: String
  image: String
  role: UserRole
  history: CourseHistoryCreateManyWithoutStudentInput
  graduated: Boolean
  password: String!
  nextOfKin: NextOfKinCreateOneWithoutStudentInput
}

input StudentCreateWithoutDepartmentInput {
  id: ID
  name: String!
  email: String!
  regNo: String!
  gender: String
  faculty: FacultyCreateOneInput
  courses: CourseCreateManyWithoutStudentsInput
  level: String
  phone: String
  address: String
  image: String
  role: UserRole
  history: CourseHistoryCreateManyWithoutStudentInput
  graduated: Boolean
  password: String!
  nextOfKin: NextOfKinCreateOneWithoutStudentInput
}

input StudentCreateWithoutHistoryInput {
  id: ID
  name: String!
  email: String!
  regNo: String!
  gender: String
  department: DepartmentCreateOneWithoutStudentsInput
  faculty: FacultyCreateOneInput
  courses: CourseCreateManyWithoutStudentsInput
  level: String
  phone: String
  address: String
  image: String
  role: UserRole
  graduated: Boolean
  password: String!
  nextOfKin: NextOfKinCreateOneWithoutStudentInput
}

input StudentCreateWithoutNextOfKinInput {
  id: ID
  name: String!
  email: String!
  regNo: String!
  gender: String
  department: DepartmentCreateOneWithoutStudentsInput
  faculty: FacultyCreateOneInput
  courses: CourseCreateManyWithoutStudentsInput
  level: String
  phone: String
  address: String
  image: String
  role: UserRole
  history: CourseHistoryCreateManyWithoutStudentInput
  graduated: Boolean
  password: String!
}

type StudentEdge {
  node: Student!
  cursor: String!
}

enum StudentOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
  regNo_ASC
  regNo_DESC
  gender_ASC
  gender_DESC
  level_ASC
  level_DESC
  phone_ASC
  phone_DESC
  address_ASC
  address_DESC
  image_ASC
  image_DESC
  role_ASC
  role_DESC
  graduated_ASC
  graduated_DESC
  password_ASC
  password_DESC
}

type StudentPreviousValues {
  id: ID!
  name: String!
  email: String!
  regNo: String!
  gender: String
  level: String
  phone: String
  address: String
  image: String
  role: UserRole!
  graduated: Boolean
  password: String!
}

input StudentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  regNo: String
  regNo_not: String
  regNo_in: [String!]
  regNo_not_in: [String!]
  regNo_lt: String
  regNo_lte: String
  regNo_gt: String
  regNo_gte: String
  regNo_contains: String
  regNo_not_contains: String
  regNo_starts_with: String
  regNo_not_starts_with: String
  regNo_ends_with: String
  regNo_not_ends_with: String
  gender: String
  gender_not: String
  gender_in: [String!]
  gender_not_in: [String!]
  gender_lt: String
  gender_lte: String
  gender_gt: String
  gender_gte: String
  gender_contains: String
  gender_not_contains: String
  gender_starts_with: String
  gender_not_starts_with: String
  gender_ends_with: String
  gender_not_ends_with: String
  level: String
  level_not: String
  level_in: [String!]
  level_not_in: [String!]
  level_lt: String
  level_lte: String
  level_gt: String
  level_gte: String
  level_contains: String
  level_not_contains: String
  level_starts_with: String
  level_not_starts_with: String
  level_ends_with: String
  level_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  role: UserRole
  role_not: UserRole
  role_in: [UserRole!]
  role_not_in: [UserRole!]
  graduated: Boolean
  graduated_not: Boolean
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  AND: [StudentScalarWhereInput!]
  OR: [StudentScalarWhereInput!]
  NOT: [StudentScalarWhereInput!]
}

type StudentSubscriptionPayload {
  mutation: MutationType!
  node: Student
  updatedFields: [String!]
  previousValues: StudentPreviousValues
}

input StudentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: StudentWhereInput
  AND: [StudentSubscriptionWhereInput!]
  OR: [StudentSubscriptionWhereInput!]
  NOT: [StudentSubscriptionWhereInput!]
}

input StudentUpdateDataInput {
  name: String
  email: String
  regNo: String
  gender: String
  department: DepartmentUpdateOneWithoutStudentsInput
  faculty: FacultyUpdateOneInput
  courses: CourseUpdateManyWithoutStudentsInput
  level: String
  phone: String
  address: String
  image: String
  role: UserRole
  history: CourseHistoryUpdateManyWithoutStudentInput
  graduated: Boolean
  password: String
  nextOfKin: NextOfKinUpdateOneWithoutStudentInput
}

input StudentUpdateInput {
  name: String
  email: String
  regNo: String
  gender: String
  department: DepartmentUpdateOneWithoutStudentsInput
  faculty: FacultyUpdateOneInput
  courses: CourseUpdateManyWithoutStudentsInput
  level: String
  phone: String
  address: String
  image: String
  role: UserRole
  history: CourseHistoryUpdateManyWithoutStudentInput
  graduated: Boolean
  password: String
  nextOfKin: NextOfKinUpdateOneWithoutStudentInput
}

input StudentUpdateManyDataInput {
  name: String
  email: String
  regNo: String
  gender: String
  level: String
  phone: String
  address: String
  image: String
  role: UserRole
  graduated: Boolean
  password: String
}

input StudentUpdateManyInput {
  create: [StudentCreateInput!]
  update: [StudentUpdateWithWhereUniqueNestedInput!]
  upsert: [StudentUpsertWithWhereUniqueNestedInput!]
  delete: [StudentWhereUniqueInput!]
  connect: [StudentWhereUniqueInput!]
  set: [StudentWhereUniqueInput!]
  disconnect: [StudentWhereUniqueInput!]
  deleteMany: [StudentScalarWhereInput!]
  updateMany: [StudentUpdateManyWithWhereNestedInput!]
}

input StudentUpdateManyMutationInput {
  name: String
  email: String
  regNo: String
  gender: String
  level: String
  phone: String
  address: String
  image: String
  role: UserRole
  graduated: Boolean
  password: String
}

input StudentUpdateManyWithoutCoursesInput {
  create: [StudentCreateWithoutCoursesInput!]
  delete: [StudentWhereUniqueInput!]
  connect: [StudentWhereUniqueInput!]
  set: [StudentWhereUniqueInput!]
  disconnect: [StudentWhereUniqueInput!]
  update: [StudentUpdateWithWhereUniqueWithoutCoursesInput!]
  upsert: [StudentUpsertWithWhereUniqueWithoutCoursesInput!]
  deleteMany: [StudentScalarWhereInput!]
  updateMany: [StudentUpdateManyWithWhereNestedInput!]
}

input StudentUpdateManyWithoutDepartmentInput {
  create: [StudentCreateWithoutDepartmentInput!]
  delete: [StudentWhereUniqueInput!]
  connect: [StudentWhereUniqueInput!]
  set: [StudentWhereUniqueInput!]
  disconnect: [StudentWhereUniqueInput!]
  update: [StudentUpdateWithWhereUniqueWithoutDepartmentInput!]
  upsert: [StudentUpsertWithWhereUniqueWithoutDepartmentInput!]
  deleteMany: [StudentScalarWhereInput!]
  updateMany: [StudentUpdateManyWithWhereNestedInput!]
}

input StudentUpdateManyWithWhereNestedInput {
  where: StudentScalarWhereInput!
  data: StudentUpdateManyDataInput!
}

input StudentUpdateOneRequiredInput {
  create: StudentCreateInput
  update: StudentUpdateDataInput
  upsert: StudentUpsertNestedInput
  connect: StudentWhereUniqueInput
}

input StudentUpdateOneRequiredWithoutHistoryInput {
  create: StudentCreateWithoutHistoryInput
  update: StudentUpdateWithoutHistoryDataInput
  upsert: StudentUpsertWithoutHistoryInput
  connect: StudentWhereUniqueInput
}

input StudentUpdateOneRequiredWithoutNextOfKinInput {
  create: StudentCreateWithoutNextOfKinInput
  update: StudentUpdateWithoutNextOfKinDataInput
  upsert: StudentUpsertWithoutNextOfKinInput
  connect: StudentWhereUniqueInput
}

input StudentUpdateWithoutCoursesDataInput {
  name: String
  email: String
  regNo: String
  gender: String
  department: DepartmentUpdateOneWithoutStudentsInput
  faculty: FacultyUpdateOneInput
  level: String
  phone: String
  address: String
  image: String
  role: UserRole
  history: CourseHistoryUpdateManyWithoutStudentInput
  graduated: Boolean
  password: String
  nextOfKin: NextOfKinUpdateOneWithoutStudentInput
}

input StudentUpdateWithoutDepartmentDataInput {
  name: String
  email: String
  regNo: String
  gender: String
  faculty: FacultyUpdateOneInput
  courses: CourseUpdateManyWithoutStudentsInput
  level: String
  phone: String
  address: String
  image: String
  role: UserRole
  history: CourseHistoryUpdateManyWithoutStudentInput
  graduated: Boolean
  password: String
  nextOfKin: NextOfKinUpdateOneWithoutStudentInput
}

input StudentUpdateWithoutHistoryDataInput {
  name: String
  email: String
  regNo: String
  gender: String
  department: DepartmentUpdateOneWithoutStudentsInput
  faculty: FacultyUpdateOneInput
  courses: CourseUpdateManyWithoutStudentsInput
  level: String
  phone: String
  address: String
  image: String
  role: UserRole
  graduated: Boolean
  password: String
  nextOfKin: NextOfKinUpdateOneWithoutStudentInput
}

input StudentUpdateWithoutNextOfKinDataInput {
  name: String
  email: String
  regNo: String
  gender: String
  department: DepartmentUpdateOneWithoutStudentsInput
  faculty: FacultyUpdateOneInput
  courses: CourseUpdateManyWithoutStudentsInput
  level: String
  phone: String
  address: String
  image: String
  role: UserRole
  history: CourseHistoryUpdateManyWithoutStudentInput
  graduated: Boolean
  password: String
}

input StudentUpdateWithWhereUniqueNestedInput {
  where: StudentWhereUniqueInput!
  data: StudentUpdateDataInput!
}

input StudentUpdateWithWhereUniqueWithoutCoursesInput {
  where: StudentWhereUniqueInput!
  data: StudentUpdateWithoutCoursesDataInput!
}

input StudentUpdateWithWhereUniqueWithoutDepartmentInput {
  where: StudentWhereUniqueInput!
  data: StudentUpdateWithoutDepartmentDataInput!
}

input StudentUpsertNestedInput {
  update: StudentUpdateDataInput!
  create: StudentCreateInput!
}

input StudentUpsertWithoutHistoryInput {
  update: StudentUpdateWithoutHistoryDataInput!
  create: StudentCreateWithoutHistoryInput!
}

input StudentUpsertWithoutNextOfKinInput {
  update: StudentUpdateWithoutNextOfKinDataInput!
  create: StudentCreateWithoutNextOfKinInput!
}

input StudentUpsertWithWhereUniqueNestedInput {
  where: StudentWhereUniqueInput!
  update: StudentUpdateDataInput!
  create: StudentCreateInput!
}

input StudentUpsertWithWhereUniqueWithoutCoursesInput {
  where: StudentWhereUniqueInput!
  update: StudentUpdateWithoutCoursesDataInput!
  create: StudentCreateWithoutCoursesInput!
}

input StudentUpsertWithWhereUniqueWithoutDepartmentInput {
  where: StudentWhereUniqueInput!
  update: StudentUpdateWithoutDepartmentDataInput!
  create: StudentCreateWithoutDepartmentInput!
}

input StudentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  regNo: String
  regNo_not: String
  regNo_in: [String!]
  regNo_not_in: [String!]
  regNo_lt: String
  regNo_lte: String
  regNo_gt: String
  regNo_gte: String
  regNo_contains: String
  regNo_not_contains: String
  regNo_starts_with: String
  regNo_not_starts_with: String
  regNo_ends_with: String
  regNo_not_ends_with: String
  gender: String
  gender_not: String
  gender_in: [String!]
  gender_not_in: [String!]
  gender_lt: String
  gender_lte: String
  gender_gt: String
  gender_gte: String
  gender_contains: String
  gender_not_contains: String
  gender_starts_with: String
  gender_not_starts_with: String
  gender_ends_with: String
  gender_not_ends_with: String
  department: DepartmentWhereInput
  faculty: FacultyWhereInput
  courses_every: CourseWhereInput
  courses_some: CourseWhereInput
  courses_none: CourseWhereInput
  level: String
  level_not: String
  level_in: [String!]
  level_not_in: [String!]
  level_lt: String
  level_lte: String
  level_gt: String
  level_gte: String
  level_contains: String
  level_not_contains: String
  level_starts_with: String
  level_not_starts_with: String
  level_ends_with: String
  level_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  role: UserRole
  role_not: UserRole
  role_in: [UserRole!]
  role_not_in: [UserRole!]
  history_every: CourseHistoryWhereInput
  history_some: CourseHistoryWhereInput
  history_none: CourseHistoryWhereInput
  graduated: Boolean
  graduated_not: Boolean
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  nextOfKin: NextOfKinWhereInput
  AND: [StudentWhereInput!]
  OR: [StudentWhereInput!]
  NOT: [StudentWhereInput!]
}

input StudentWhereUniqueInput {
  id: ID
  email: String
  regNo: String
}

type Subscription {
  course(where: CourseSubscriptionWhereInput): CourseSubscriptionPayload
  courseHistory(where: CourseHistorySubscriptionWhereInput): CourseHistorySubscriptionPayload
  department(where: DepartmentSubscriptionWhereInput): DepartmentSubscriptionPayload
  faculty(where: FacultySubscriptionWhereInput): FacultySubscriptionPayload
  grade(where: GradeSubscriptionWhereInput): GradeSubscriptionPayload
  lecturer(where: LecturerSubscriptionWhereInput): LecturerSubscriptionPayload
  nextOfKin(where: NextOfKinSubscriptionWhereInput): NextOfKinSubscriptionPayload
  result(where: ResultSubscriptionWhereInput): ResultSubscriptionPayload
  session(where: SessionSubscriptionWhereInput): SessionSubscriptionPayload
  student(where: StudentSubscriptionWhereInput): StudentSubscriptionPayload
}

enum UserRole {
  ADMIN
  STUDENT
  LECTURER
  OTHERS
}
`
      }
    